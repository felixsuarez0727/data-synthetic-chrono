"""
Module for generating synthetic data using the Chronos-T5 model
"""

import os
import json
import pandas as pd
import numpy as np
import torch
import logging
import yaml
from typing import List, Dict, Tuple, Optional, Union
from tqdm import tqdm
import re

from src.model_loader import ChronosModelLoader
import torch

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class SyntheticDataGenerator:
    """
    Class for generating synthetic data using Chronos-T5
    """
    
    def __init__(self, config_path="config/config.yaml"):
        """
        Initializes the generator with the specified configuration
        
        Args:
            config_path: Path to the YAML configuration file
        """
        with open(config_path, 'r', encoding='utf-8') as file:
            self.config = yaml.safe_load(file)
        
        self.processed_path = self.config['data']['processed_path']
        self.synthetic_path = self.config['data']['synthetic_path']
        
        # Create directories if they don't exist
        os.makedirs(self.synthetic_path, exist_ok=True)
        
        # Load the Chronos-T5 model
        self.model_loader = ChronosModelLoader(config_path)
        self.model, self.tokenizer = self.model_loader.load_model()
        self.generation_params = self.model_loader.get_generation_params()
        
        # Generation configuration
        self.batch_size = self.config['generation']['batch_size']
        self.num_synthetic_samples = self.config['generation']['num_synthetic_samples']
        self.seed = self.config['generation']['seed']
        
        # Set seed for reproducibility
        torch.manual_seed(self.seed)
        np.random.seed(self.seed)
    
    def generate(self, time_series_data: Union[List[torch.Tensor], torch.Tensor]) -> List[np.ndarray]:
        """
        Generates synthetic forecasts from time series data
        
        Args:
            time_series_data: List of tensors or tensor with time series data
            
        Returns:
            List of numpy arrays with generated synthetic forecasts
        """
        logger.info(f"Starting synthetic data generation for time series...")
        
        # If it's a list of individual tensors, process them one by one
        if isinstance(time_series_data, list):
            all_forecasts = []
            
            for i, series in enumerate(tqdm(time_series_data, desc="Generating synthetic data")):
                # Generate forecasts using the Chronos pipeline
                forecasts = self.model_loader.generate_forecasts(
                    series, 
                    prediction_length=self.generation_params.get('max_length', 24)
                )
                all_forecasts.append(forecasts)
            
            logger.info(f"Generated synthetic forecasts for {len(all_forecasts)} time series")
            return all_forecasts
        
        # If it's a single tensor, process it directly
        else:
            forecasts = self.model_loader.generate_forecasts(
                time_series_data,
                prediction_length=self.generation_params.get('max_length', 24)
            )
            
            logger.info(f"Generated synthetic forecasts for one time series")
            return [forecasts]
    
    def _parse_generated_text(self, text: str) -> Dict:
        """
        Parses the generated text into a dictionary of values
        
        Args:
            text: Text generated by the model
            
        Returns:
            Dictionary with parsed values
        """
        # Extract key-value pairs from the generated text
        # This parser must be adapted to the specific format used by the model
        pairs = {}
        
        # Try to extract as if it were a "key: value, key2: value2" format
        pattern = r'([^,]+):\s*([^,]+)(?:,|$)'
        matches = re.findall(pattern, text)
        
        for key, value in matches:
            key = key.strip()
            value = value.strip()
            
            # Try to convert numeric values
            try:
                if '.' in value:
                    value = float(value)
                else:
                    value = int(value)
            except ValueError:
                pass  # Keep as string if not numeric
            
            pairs[key] = value
        
        return pairs
    
    def generate_synthetic_dataset(self, time_series_data: List[torch.Tensor], 
                                   original_df: pd.DataFrame, 
                                   output_file: str = "synthetic_data.csv") -> pd.DataFrame:
        """
        Generates a complete synthetic dataset from time series
        
        Args:
            time_series_data: List of tensors with time series
            original_df: Original DataFrame for structure reference
            output_file: Name of the output file
            
        Returns:
            DataFrame with synthetic data
        """
        logger.info(f"Generating synthetic dataset from {len(time_series_data)} time series")
        
        # Generate forecasts with Chronos
        forecasts = self.generate(time_series_data)
        
        # Convert forecasts to DataFrame
        synthetic_data = []
        
        # Create columns for synthetic data
        for i, forecast_batch in enumerate(forecasts):
            # forecast_batch has shape [num_samples, prediction_length]
            num_samples, pred_length = forecast_batch.shape[:2]
            
            # For each sample in the batch
            for sample_idx in range(num_samples):
                sample_forecast = forecast_batch[sample_idx]
                
                # Create a dictionary with the synthetic series
                row_dict = {
                    'series_id': f'synthetic_{i}_{sample_idx}',
                    'source_series': i,
                    'sample_id': sample_idx
                }
                
                # Add each prediction point as a column
                for t in range(pred_length):
                    row_dict[f'value_t{t}'] = float(sample_forecast[t])
                
                synthetic_data.append(row_dict)
        
        # Create DataFrame with synthetic data
        synthetic_df = pd.DataFrame(synthetic_data)
        
        # Save synthetic data
        output_path = os.path.join(self.synthetic_path, output_file)
        synthetic_df.to_csv(output_path, index=False)
        logger.info(f"Synthetic data saved to {output_path}")
        
        # Also save each individual series in appropriate format
        for i, forecast_batch in enumerate(forecasts):
            # Save the median (50th percentile) as the main prediction
            median_forecast = np.median(forecast_batch, axis=0)
            
            # Calculate prediction intervals (10% and 90%)
            lower_bound = np.percentile(forecast_batch, 10, axis=0)
            upper_bound = np.percentile(forecast_batch, 90, axis=0)
            
            # Create DataFrame with the prediction and its intervals
            forecast_df = pd.DataFrame({
                'time_idx': list(range(len(median_forecast))),
                'median_forecast': median_forecast,
                'lower_bound': lower_bound,
                'upper_bound': upper_bound
            })
            
            # Save to separate file
            forecast_path = os.path.join(self.synthetic_path, f'forecast_series_{i}.csv')
            forecast_df.to_csv(forecast_path, index=False)
            logger.info(f"Forecast for series {i} saved to {forecast_path}")
        
        return synthetic_df


if __name__ == "__main__":
    # Quick test of the generator
    from src.data_preprocessing import DataPreprocessor
    
    try:
        # Load and preprocess data
        preprocessor = DataPreprocessor()
        df = preprocessor.load_data("sample.csv")
        processed_df = preprocessor.preprocess_data(df)
        
        # Format for Chronos-T5
        formatted_texts = preprocessor.prepare_for_chronos(processed_df)
        
        # Generate synthetic data
        generator = SyntheticDataGenerator()
        synthetic_df = generator.generate_synthetic_dataset(
            formatted_texts[:10],  # Use only 10 for testing
            processed_df,
            "test_synthetic.csv"
        )
        
        print(f"Synthetic data generated with shape: {synthetic_df.shape}")
        print(synthetic_df.head(2))
        
    except FileNotFoundError:
        print("Example file not found. Please place a file in the 'data/raw/' folder")
    except Exception as e:
        print(f"Error during testing: {str(e)}")